# Shared shell functions for bash and zsh
# Sourced by both ~/.bashrc and ~/.zshrc

# Make directory and cd into it
mkcd() {
  mkdir -p "$1" && cd "$1"
}

# Extract various archive formats
extract() {
  if [ -f "$1" ]; then
    case "$1" in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar x "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Find process by name
psgrep() {
  ps aux | grep -v grep | grep -i -e VSZ -e "$@"
}

# Quick search in current directory
search() {
  find . -iname "*$@*" 2>/dev/null
}

# Python virtual environment helper
venv() {
  # If a virtual environment is already active, deactivate it
  if [ -n "$VIRTUAL_ENV" ]; then
    # Remove the venv bin directory from PATH
    if [ -n "$_VENV_ORIGINAL_PATH" ]; then
      export PATH="$_VENV_ORIGINAL_PATH"
      unset _VENV_ORIGINAL_PATH
    fi
    # Call standard deactivate if available
    if type deactivate &>/dev/null; then
      deactivate
    fi
    unset VIRTUAL_ENV
    echo "✓ Deactivated virtual environment"
    return 0
  fi

  # Check for existing virtual environments
  local venv_path=""
  if [ -d ".venv" ]; then
    venv_path=".venv"
  elif [ -d "venv" ]; then
    venv_path="venv"
  else
    echo "No virtual environment found in current directory."
    echo -n "Create one in .venv? [y/N] "
    read response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      # Check if python3 is available
      if ! command -v python3 &>/dev/null; then
        echo "✗ python3 command not found"
        return 1
      fi

      # Capture both stdout and stderr
      local error_output
      error_output=$(python3 -m venv .venv 2>&1)
      local exit_code=$?

      if [ $exit_code -eq 0 ]; then
        venv_path=".venv"
        echo "✓ Created virtual environment in .venv"

        # Check if requirements.txt exists and offer to install packages
        if [ -f "requirements.txt" ]; then
          echo -n "Install packages from requirements.txt? [y/N] "
          read install_response
          if [[ "$install_response" =~ ^[Yy]$ ]]; then
            echo "Installing packages..."
            .venv/bin/pip install -r requirements.txt
            if [ $? -eq 0 ]; then
              echo "✓ Packages installed successfully"
            else
              echo "✗ Failed to install some packages"
            fi
          fi
        fi
      else
        echo "✗ Failed to create virtual environment"
        if [ -n "$error_output" ]; then
          echo "  Error details: $error_output"
        fi
        echo "  Python path: $(command -v python3)"
        echo "  Python version: $(python3 --version 2>&1)"
        return 1
      fi
    else
      return 0
    fi
  fi

  # Activate the virtual environment
  if [ -n "$venv_path" ]; then
    # Store original PATH for restoration on deactivation
    export _VENV_ORIGINAL_PATH="$PATH"

    # Add venv bin directory to PATH
    export PATH="$(pwd)/$venv_path/bin:$PATH"
    export VIRTUAL_ENV="$(pwd)/$venv_path"

    # Also source the activate script for other environment setup
    source "$venv_path/bin/activate"

    echo "✓ Activated virtual environment ($venv_path)"
    echo "  Scripts from installed packages are now on your PATH"
  fi
}

# ============================================================================
# GitHub Account Switching Helpers
# ============================================================================
# Dynamically creates gh-{name} commands based on ~/.gh-accounts config file
# Configuration uses git config (INI) format for easy parsing
# ============================================================================

# Show current GitHub and git configuration
# Note: gh-setup is now a standalone script at ~/.local/bin/gh-setup
gh-whoami() {
  echo "gh account: $(gh api user --jq .login 2>/dev/null || echo 'not authenticated')"
  echo "git user: $(git config user.name) <$(git config user.email)>"
}

# Gist command using gh CLI
# Automatically uses current gh auth, so switching accounts with gh-{name}
# also switches the gist identity
gist() {
  gh gist "$@"
}

# ============================================================================
# Dynamic Function Generation
# ============================================================================
# This section reads ~/.gh-accounts and creates a gh-{name} function for
# each configured account. The functions are created when the shell starts.
# ============================================================================

# Only proceed if config file exists
if [[ -f ~/.gh-accounts ]]; then
  # Get list of all account names from the config
  while IFS= read -r _account; do
    # Use eval to create a function with the account name
    eval "gh-$_account() {
      local account_name='$_account'
      local config_file=~/.gh-accounts

      # Read account settings from config
      local gh_user=\$(git config -f \"\$config_file\" \"account.\$account_name.user\")
      local git_name=\$(git config -f \"\$config_file\" \"account.\$account_name.name\")
      local git_email=\$(git config -f \"\$config_file\" \"account.\$account_name.email\")

      # Read optional GPG settings
      local gpg_key=\$(git config -f \"\$config_file\" \"account.\$account_name.signingkey\")
      local gpg_program=\$(git config -f \"\$config_file\" \"account.\$account_name.gpgprogram\")

      # Validate we have all required settings
      if [[ -z \"\$gh_user\" ]] || [[ -z \"\$git_name\" ]] || [[ -z \"\$git_email\" ]]; then
        echo \"⚠ Account '\$account_name' is not properly configured\"
        echo \"Run 'gh-setup' to configure it\"
        return 1
      fi

      # Switch gh CLI to this account
      gh auth switch --user \"\$gh_user\" 2>/dev/null || {
        echo \"⚠ Failed to switch gh CLI to \$gh_user\"
        echo \"Make sure you've authenticated with: gh auth login\"
        return 1
      }

      # Write git user config to ~/.gitconfig.local using printf
      # This keeps user info out of the tracked dotfiles
      {
        printf '[user]\\n'
        printf '  name = %s\\n' \"\$git_name\"
        printf '  email = %s\\n' \"\$git_email\"
        # Add GPG signing config if key is configured for this account
        if [[ -n \"\$gpg_key\" ]]; then
          printf '  signingkey = %s\\n' \"\$gpg_key\"
          printf '[commit]\\n'
          printf '  gpgsign = true\\n'
          if [[ -n \"\$gpg_program\" ]]; then
            printf '[gpg]\\n'
            printf '  program = %s\\n' \"\$gpg_program\"
          fi
        fi
      } > ~/.gitconfig.local

      echo \"✓ Switched to \$account_name account (\$gh_user / \$git_name <\$git_email>)\"
      if [[ -n \"\$gpg_key\" ]]; then
        echo \"  GPG signing enabled (key: \$gpg_key)\"
      fi
    }"
  done < <(git config -f ~/.gh-accounts --get-regexp '^account\.' | \
           sed 's/^account\.\([^.]*\)\..*/\1/' | sort -u)
fi
