# Shared shell functions for bash and zsh
# Sourced by both ~/.bashrc and ~/.zshrc

# Make directory and cd into it
mkcd() {
  mkdir -p "$1" && cd "$1"
}

# Extract various archive formats
extract() {
  if [ -f "$1" ]; then
    case "$1" in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar x "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Find process by name
psgrep() {
  ps aux | grep -v grep | grep -i -e VSZ -e "$@"
}

# Quick search in current directory
search() {
  find . -iname "*$@*" 2>/dev/null
}

# Python virtual environment helper
venv() {
  # If a virtual environment is already active, deactivate it
  if [ -n "$VIRTUAL_ENV" ]; then
    # Remove the venv bin directory from PATH
    if [ -n "$_VENV_ORIGINAL_PATH" ]; then
      export PATH="$_VENV_ORIGINAL_PATH"
      unset _VENV_ORIGINAL_PATH
    fi
    # Call standard deactivate if available
    if type deactivate &>/dev/null; then
      deactivate
    fi
    unset VIRTUAL_ENV
    echo "✓ Deactivated virtual environment"
    return 0
  fi

  # Check for existing virtual environments
  local venv_path=""
  if [ -d ".venv" ]; then
    venv_path=".venv"
  elif [ -d "venv" ]; then
    venv_path="venv"
  else
    echo "No virtual environment found in current directory."
    echo -n "Create one in .venv? [y/N] "
    read response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      python3 -m venv .venv
      if [ $? -eq 0 ]; then
        venv_path=".venv"
      else
        echo "✗ Failed to create virtual environment"
        return 1
      fi
    else
      return 0
    fi
  fi

  # Activate the virtual environment
  if [ -n "$venv_path" ]; then
    # Store original PATH for restoration on deactivation
    export _VENV_ORIGINAL_PATH="$PATH"

    # Add venv bin directory to PATH
    export PATH="$(pwd)/$venv_path/bin:$PATH"
    export VIRTUAL_ENV="$(pwd)/$venv_path"

    # Also source the activate script for other environment setup
    source "$venv_path/bin/activate"

    echo "✓ Activated virtual environment ($venv_path)"
    echo "  Scripts from installed packages are now on your PATH"
  fi
}

# ============================================================================
# GitHub Account Switching Helpers
# ============================================================================
# Dynamically creates gh-{name} commands based on ~/.gh-accounts config file
# Configuration uses git config (INI) format for easy parsing
# ============================================================================

# Show current GitHub and git configuration
# Note: gh-setup is now a standalone script at ~/.local/bin/gh-setup
gh-whoami() {
  echo "gh account: $(gh api user --jq .login 2>/dev/null || echo 'not authenticated')"
  echo "git user: $(git config user.name) <$(git config user.email)>"
}

# ============================================================================
# Dynamic Function Generation
# ============================================================================
# This section reads ~/.gh-accounts and creates a gh-{name} function for
# each configured account. The functions are created when the shell starts.
# ============================================================================

# Only proceed if config file exists
if [[ -f ~/.gh-accounts ]]; then
  # Get list of all account names from the config
  while IFS= read -r _account; do
    # Use eval to create a function with the account name
    eval "gh-$_account() {
      local account_name='$_account'
      local config_file=~/.gh-accounts

      # Read account settings from config
      local gh_user=\$(git config -f \"\$config_file\" \"account.\$account_name.user\")
      local git_name=\$(git config -f \"\$config_file\" \"account.\$account_name.name\")
      local git_email=\$(git config -f \"\$config_file\" \"account.\$account_name.email\")

      # Validate we have all required settings
      if [[ -z \"\$gh_user\" ]] || [[ -z \"\$git_name\" ]] || [[ -z \"\$git_email\" ]]; then
        echo \"⚠ Account '\$account_name' is not properly configured\"
        echo \"Run 'gh-setup' to configure it\"
        return 1
      fi

      # Switch gh CLI to this account
      gh auth switch --user \"\$gh_user\" 2>/dev/null || {
        echo \"⚠ Failed to switch gh CLI to \$gh_user\"
        echo \"Make sure you've authenticated with: gh auth login\"
        return 1
      }

      # Write git user config to ~/.gitconfig.local using printf
      # This keeps user info out of the tracked dotfiles
      {
        printf '[user]\\n'
        printf '  name = %s\\n' \"\$git_name\"
        printf '  email = %s\\n' \"\$git_email\"
      } > ~/.gitconfig.local

      echo \"✓ Switched to \$account_name account (\$gh_user / \$git_name <\$git_email>)\"
    }"
  done < <(git config -f ~/.gh-accounts --get-regexp '^account\.' | \
           sed 's/^account\.\([^.]*\)\..*/\1/' | sort -u)
fi
